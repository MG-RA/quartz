<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>irrev graph viewer (d3)</title>
    <style>
      :root {
        --bg: #0b0d10;
        --panel: #11161c;
        --fg: #e6edf3;
        --muted: #9aa4ad;
        --accent: #59a6ff;
        --edge-links: rgba(154, 164, 173, 0.25);
        --edge-depends: rgba(89, 166, 255, 0.6);
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      }
      .app {
        display: grid;
        grid-template-columns: 340px 1fr;
        height: 100%;
      }
      .panel {
        background: var(--panel);
        border-right: 1px solid rgba(255, 255, 255, 0.08);
        padding: 14px;
        overflow: auto;
      }
      h1 {
        font-size: 14px;
        margin: 0 0 10px 0;
        letter-spacing: 0.2px;
      }
      .hint {
        color: var(--muted);
        margin: 0 0 12px 0;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        margin: 10px 0 14px 0;
      }
      input[type="file"] {
        width: 100%;
      }
      label {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        color: var(--muted);
        user-select: none;
      }
      .stats {
        margin-top: 12px;
        color: var(--muted);
      }
      .stats code {
        color: var(--fg);
      }
      .tooltip {
        position: fixed;
        pointer-events: none;
        background: rgba(17, 22, 28, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.12);
        padding: 8px 10px;
        border-radius: 8px;
        color: var(--fg);
        font-size: 12px;
        max-width: 420px;
        display: none;
        white-space: nowrap;
      }
      .tooltip .muted {
        color: var(--muted);
      }
      #viz {
        position: relative;
      }
      svg {
        display: block;
        width: 100%;
        height: 100%;
      }
      .legend {
        display: grid;
        gap: 6px;
        margin-top: 10px;
        color: var(--muted);
      }
      .swatch {
        width: 14px;
        height: 4px;
        border-radius: 2px;
        display: inline-block;
        margin-right: 8px;
        vertical-align: middle;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="panel">
        <h1>irrev graph viewer (d3)</h1>
        <p class="hint">
          Load a JSON export shaped like
          <code>{"nodes":[...],"links":[...]}</code>
          where each node has <code>id</code> and each link has <code>source</code>, <code>target</code>, <code>type</code>.
        </p>

        <div class="row">
          <input id="file" type="file" accept="application/json,.json" />
          <label>
            <input id="showLinks" type="checkbox" checked />
            show <code>LINKS_TO</code>
          </label>
          <label>
            <input id="showDepends" type="checkbox" checked />
            show <code>DEPENDS_ON</code>
          </label>
          <label>
            <input id="showLabels" type="checkbox" />
            show labels (slow)
          </label>
        </div>

        <div class="legend">
          <div><span class="swatch" style="background: var(--edge-links)"></span>LINKS_TO (“what the text touches”)</div>
          <div><span class="swatch" style="background: var(--edge-depends)"></span>DEPENDS_ON (“what the structure requires”)</div>
        </div>

        <div class="stats" id="stats"></div>
        <p class="hint">
          Tip: export concept-only graphs first; 78 nodes / 647 edges is still fine, but dense.
        </p>
      </div>

      <div id="viz"></div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
      const fileInput = document.getElementById("file");
      const showLinks = document.getElementById("showLinks");
      const showDepends = document.getElementById("showDepends");
      const showLabels = document.getElementById("showLabels");
      const viz = document.getElementById("viz");
      const tooltip = document.getElementById("tooltip");
      const stats = document.getElementById("stats");

      const communityPalette = d3.schemeTableau10;
      const edgeColor = (type) => (type === "DEPENDS_ON" ? "var(--edge-depends)" : "var(--edge-links)");

      let graph = null;
      let render = null;

      function setStats(g) {
        const n = g?.nodes?.length ?? 0;
        const e = g?.links?.length ?? 0;
        const dep = g?.links?.filter((l) => l.type === "DEPENDS_ON").length ?? 0;
        const lnk = g?.links?.filter((l) => l.type === "LINKS_TO").length ?? 0;
        stats.innerHTML = [
          `<div>nodes: <code>${n}</code></div>`,
          `<div>edges: <code>${e}</code> (<code>${lnk}</code> LINKS_TO, <code>${dep}</code> DEPENDS_ON)</div>`,
        ].join("");
      }

      function showTip(evt, node) {
        tooltip.style.display = "block";
        tooltip.style.left = `${evt.clientX + 12}px`;
        tooltip.style.top = `${evt.clientY + 12}px`;
        const parts = [
          `<div><code>${escapeHtml(node.id)}</code></div>`,
          node.label ? `<div>${escapeHtml(node.label)}</div>` : "",
          `<div class="muted">${escapeHtml([node.role, node.layer, node.community].filter(Boolean).join(" · "))}</div>`,
        ];
        tooltip.innerHTML = parts.filter(Boolean).join("");
      }

      function hideTip() {
        tooltip.style.display = "none";
      }

      function escapeHtml(s) {
        return String(s ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#39;");
      }

      function filteredLinks(g) {
        return (g.links || []).filter((l) => {
          if (l.type === "LINKS_TO" && !showLinks.checked) return false;
          if (l.type === "DEPENDS_ON" && !showDepends.checked) return false;
          return true;
        });
      }

      function startRender(g) {
        viz.innerHTML = "";
        const width = viz.clientWidth;
        const height = viz.clientHeight;
        const links = filteredLinks(g).map((l) => ({ ...l }));
        const nodes = (g.nodes || []).map((n) => ({ ...n }));
        const nodeById = new Map(nodes.map((n) => [n.id, n]));

        for (const l of links) {
          if (typeof l.source === "string") l.source = nodeById.get(l.source) || l.source;
          if (typeof l.target === "string") l.target = nodeById.get(l.target) || l.target;
        }

        const svg = d3.select(viz).append("svg").attr("viewBox", [0, 0, width, height]);
        const gAll = svg.append("g");

        const zoom = d3
          .zoom()
          .scaleExtent([0.05, 6])
          .on("zoom", (event) => gAll.attr("transform", event.transform));
        svg.call(zoom);

        const linkSel = gAll
          .append("g")
          .attr("stroke-linecap", "round")
          .selectAll("line")
          .data(links)
          .join("line")
          .attr("stroke", (d) => edgeColor(d.type))
          .attr("stroke-width", (d) => (d.type === "DEPENDS_ON" ? 1.3 : 0.8));

        const nodeSel = gAll
          .append("g")
          .selectAll("circle")
          .data(nodes)
          .join("circle")
          .attr("r", (d) => (d.role === "concept" ? 4.2 : 3.2))
          .attr("fill", (d) => {
            const c = d.community || "c0";
            const idx = Math.abs(hash(c)) % communityPalette.length;
            return communityPalette[idx];
          })
          .attr("stroke", "rgba(255,255,255,0.18)")
          .attr("stroke-width", 0.8)
          .on("mousemove", (event, d) => showTip(event, d))
          .on("mouseleave", hideTip);

        const labelSel = gAll
          .append("g")
          .attr("font-size", 10)
          .attr("fill", "rgba(230,237,243,0.85)")
          .selectAll("text")
          .data(nodes)
          .join("text")
          .text((d) => (d.label ? d.label : d.id))
          .style("display", showLabels.checked ? null : "none");

        const sim = d3
          .forceSimulation(nodes)
          .force(
            "link",
            d3
              .forceLink(links)
              .id((d) => d.id)
              .distance((d) => (d.type === "DEPENDS_ON" ? 35 : 18))
              .strength((d) => (d.type === "DEPENDS_ON" ? 0.75 : 0.2)),
          )
          .force("charge", d3.forceManyBody().strength(-65))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collide", d3.forceCollide().radius(8));

        sim.on("tick", () => {
          linkSel
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);

          nodeSel.attr("cx", (d) => d.x).attr("cy", (d) => d.y);

          labelSel.attr("x", (d) => d.x + 7).attr("y", (d) => d.y + 3);
        });

        function hash(s) {
          let h = 0;
          for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) | 0;
          return h;
        }

        render = () => {
          const newLinks = filteredLinks(g).map((l) => ({ ...l }));
          for (const l of newLinks) {
            if (typeof l.source === "string") l.source = nodeById.get(l.source) || l.source;
            if (typeof l.target === "string") l.target = nodeById.get(l.target) || l.target;
          }

          linkSel.data(newLinks);
          linkSel
            .join("line")
            .attr("stroke", (d) => edgeColor(d.type))
            .attr("stroke-width", (d) => (d.type === "DEPENDS_ON" ? 1.3 : 0.8));

          labelSel.style("display", showLabels.checked ? null : "none");

          sim.force(
            "link",
            d3
              .forceLink(newLinks)
              .id((d) => d.id)
              .distance((d) => (d.type === "DEPENDS_ON" ? 35 : 18))
              .strength((d) => (d.type === "DEPENDS_ON" ? 0.75 : 0.2)),
          );
          sim.alpha(0.6).restart();
        };
      }

      function setGraph(g) {
        graph = g;
        setStats(g);
        startRender(g);
      }

      function tryParseGraph(text) {
        const g = JSON.parse(text);
        if (!g || !Array.isArray(g.nodes) || !Array.isArray(g.links)) {
          throw new Error("Expected JSON object with {nodes: [...], links: [...]}");
        }
        return g;
      }

      fileInput.addEventListener("change", async () => {
        const f = fileInput.files?.[0];
        if (!f) return;
        try {
          const text = await f.text();
          setGraph(tryParseGraph(text));
        } catch (e) {
          alert(`Failed to load graph JSON: ${e?.message || e}`);
        }
      });

      showLinks.addEventListener("change", () => render?.());
      showDepends.addEventListener("change", () => render?.());
      showLabels.addEventListener("change", () => render?.());
    </script>
  </body>
</html>

